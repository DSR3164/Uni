Ниже приведён подробный разбор каждой строки и блока кода из файла 2.cpp:

---

### Подключение библиотек

```cpp
#include <iostream>    // Подключает библиотеку для ввода/вывода (cout, cin и т.д.).
#include <vector>      // Подключает контейнер vector для работы с динамическими массивами.
#include <queue>       // Подключает контейнер priority_queue для работы с очередями с приоритетом.
#include <chrono>      // Подключает средства для измерения времени (high_resolution_clock и т.д.).
#include <cmath>       // Подключает математические функции (sqrt, pow и т.д.).
#include <fstream>     // Подключает средства работы с файлами (ifstream, ofstream).
#include <cstdlib>     // Подключает функции стандартной библиотеки, такие как rand() и exit().
#include <ctime>       // Подключает функции работы со временем (time()).
#include <limits>      // Позволяет использовать свойства типов, например, numeric_limits<int>::max().
#include <algorithm>   // Подключает алгоритмы STL, например, min() для нахождения минимума.
```

Каждая из этих строк подключает стандартные библиотеки, необходимые для различных операций в программе: от работы с потоками ввода-вывода до алгоритмов и измерения времени.

---

### Пространства имён

```cpp
using namespace std;      // Позволяет не указывать префикс std:: перед стандартными элементами.
using namespace chrono;   // Позволяет напрямую использовать элементы из std::chrono.
```

Это сокращает запись, чтобы не писать каждый раз `std::` или `chrono::` перед именами классов и функций.

---

### Класс TournamentTree

Этот класс реализует турнирное дерево для нахождения минимального элемента (чемпиона) и последовательного его исключения.

#### Объявление класса и закрытые данные

```cpp
class TournamentTree
{
private:
    vector<int> nodes;   // Вектор для хранения элементов дерева, включая листья и внутренние узлы.
    int capacity;        // Количество элементов-леев (исходный размер массива).
```

- **nodes** – массив, в котором хранится вся структура дерева. Элементы с индексами от capacity до 2*capacity-1 представляют листья.
- **capacity** – число элементов в исходном массиве (количество листьев).

#### Метод initializeTree()

```cpp
    void initializeTree()
    {
        for (int i = capacity - 1; i > 0; --i)
        {
            nodes[i] = min(nodes[2 * i], nodes[2 * i + 1]);
        }
    }
```

- **Цикл**: начинается с узла, который является родительским для последних листьев, и двигается к корню (индекс 1).
- **Внутри цикла**: для каждого узла вычисляется минимум из его двух детей (находящихся по индексам `2*i` и `2*i+1`), что позволяет сформировать турнирное дерево, где в каждом узле хранится минимальное значение поддерева.

#### Метод refreshTree()

```cpp
    void refreshTree(int index)
    {
        int current = (index + capacity) / 2;
        while (current > 0)
        {
            nodes[current] = min(nodes[2 * current], nodes[2 * current + 1]);
            current /= 2;
        }
    }
```

- **Цель метода**: обновить значения в узлах дерева после изменения значения одного из листьев.
- **Параметр index** – индекс листа (относительно исходного массива), который был изменён.
- **Вычисление current**: перевод индекса листа в индекс его родительского узла.
- **Цикл while**: поднимается от изменённого узла к корню, на каждом шаге пересчитывая минимум двух дочерних узлов, чтобы восстановить корректное значение для родительского узла.

#### Публичные методы и конструктор

```cpp
public:
    TournamentTree(const vector<int> &elements)
    {
        capacity = elements.size();       // Устанавливает количество листьев.
        nodes.resize(2 * capacity);         // Выделяет место для всех узлов: листья + внутренние узлы.
        for (int i = 0; i < capacity; ++i)
        {
            nodes[capacity + i] = elements[i];  // Копирует исходные элементы в позицию листьев (начиная с индекса capacity).
        }
        initializeTree();                   // Инициализирует внутренние узлы, вычисляя минимумы.
    }
```

- **Конструктор** получает исходный массив элементов.
- **capacity** устанавливается равным числу элементов.
- **nodes.resize(2 * capacity)** – резервирует место для всех узлов дерева.
- Цикл копирует элементы в "листья" дерева.
- **initializeTree()** – строит дерево, вычисляя минимальные значения для внутренних узлов.

```cpp
    int getChampion() const
    {
        return nodes[1];  // Корень дерева (индекс 1) содержит минимальное значение, то есть чемпиона.
    }
```

- Метод возвращает минимальное значение, которое хранится в корне турнирного дерева.

```cpp
    void eliminateChampion()
    {
        int champion = getChampion();   // Сохраняет текущее минимальное значение.
        for (int i = 0; i < capacity; ++i)
        {
            if (nodes[capacity + i] == champion)  // Ищет первый лист, равный чемпиону.
            {
                nodes[capacity + i] = numeric_limits<int>::max(); // Заменяет найденное значение на максимальное, чтобы исключить его.
                refreshTree(i);         // Обновляет дерево, начиная с изменённого листа.
                break;                  // Прерывает цикл после исключения одного чемпиона.
            }
        }
    }
```

- Метод ищет лист, содержащий текущее минимальное значение, и «исключает» его, присваивая максимальное возможное значение.
- Затем вызывается **refreshTree()** для пересчёта значений по пути к корню.

```cpp
    void processAllRounds()
    {
        for (int i = 0; i < capacity; ++i)
        {
            eliminateChampion();   // Последовательно исключает чемпионов, пока не будут обработаны все листья.
        }
    }
};
```

- Метод последовательно вызывает **eliminateChampion()** столько раз, сколько элементов (листьев) имеется, что приводит к полному "очищению" дерева.

---

### Функция createRandomDataset()

```cpp
vector<int> createRandomDataset(int count)
{
    vector<int> dataset(count);         // Создаёт вектор заданного размера.
    for (int i = 0; i < count; ++i)
    {
        dataset[i] = rand() % 100000;     // Заполняет вектор случайными числами от 0 до 99999.
    }
    return dataset;                     // Возвращает заполненный случайными значениями вектор.
}
```

- Функция создаёт и возвращает набор случайных чисел указанного размера.
- **rand() % 100000** генерирует случайное число, ограниченное верхней границей 100000.

---

### Функция writeResultsToFile()

```cpp
void writeResultsToFile(const vector<pair<int, pair<double, double>>> &data, const string &filePath)
{
    ofstream output(filePath);  // Открывает файл для записи по заданному пути.
    if (!output.is_open())
    {
        cerr << "Error: Unable to open file for writing!\n";  // Выводит сообщение об ошибке, если файл не открылся.
        return;               // Прерывает выполнение функции.
    }
    output << "ArraySize\tWinnerTree(s)\tMinHeap(s)\n";  // Записывает заголовок таблицы результатов.
    for (const auto &entry : data)
    {
        output << entry.first << "\t" << entry.second.first << "\t" << entry.second.second << "\n";  
        // Для каждого набора данных записывает: размер массива, время работы WinnerTree и время работы MinHeap.
    }
    output.close();           // Закрывает файл.
}
```

- Функция записывает результаты измерений в текстовый файл.
- Результаты представлены в виде таблицы с размером массива и временем работы двух методов (турнирного дерева и мин-кучи).

---

### Функция main()

```cpp
int main()
{
    srand(static_cast<unsigned>(time(0)));
    // Инициализирует генератор случайных чисел текущим временем, чтобы последовательность чисел была разной при каждом запуске.
```

- **srand(static_cast<unsigned>(time(0)))** – инициализация генератора случайных чисел, используя текущее время.

```cpp
    vector<int> datasetSizes = {16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 16384, 65536, 100000};
    // Создаёт вектор размеров наборов данных для тестирования.
```

- Перечисляются различные размеры массивов для проведения бенчмаркинга.

```cpp
    vector<pair<int, pair<double, double>>> performanceMetrics;
    // Создаёт вектор для хранения результатов измерения производительности.
    // Каждый элемент – пара, где первый элемент – размер массива, а второй – пара времен выполнения:
    // первое значение для TournamentTree, второе – для priority_queue (мин-кучи).
```

```cpp
    for (int size : datasetSizes)
    {
        vector<int> dataset = createRandomDataset(size);
        // Для каждого размера создаётся случайный набор данных.
```

- Цикл по каждому размеру массива из набора **datasetSizes**.

```cpp
        auto startTime = high_resolution_clock::now();
        TournamentTree tree(dataset);
        tree.processAllRounds();
        auto endTime = high_resolution_clock::now();
        double treeDuration = duration_cast<microseconds>(endTime - startTime).count() / 1e6;
        // Измеряется время, затраченное на создание турнирного дерева и последовательное исключение чемпионов.
        // Результат переводится в секунды (микросекунды делятся на 1e6).
```

- Сначала замеряется время начала работы.
- Создаётся объект турнирного дерева по заданному набору данных.
- Вызывается метод **processAllRounds()**, который поочерёдно исключает минимальные элементы.
- Измеряется время окончания, разница переводится в секунды.

```cpp
        startTime = high_resolution_clock::now();
        priority_queue<int, vector<int>, greater<>> heap(dataset.begin(), dataset.end());
        while (!heap.empty())
        {
            heap.pop();
        }
        endTime = high_resolution_clock::now();
        double heapDuration = duration_cast<microseconds>(endTime - startTime).count() / 1e6;
        // Измеряется время работы стандартной очереди с приоритетом (мин-кучи):
        // создаётся очередь с элементами набора данных, затем все элементы извлекаются методом pop().
```

- Здесь производится аналогичный бенчмарк для стандартной структуры данных **priority_queue** (с компаратором **greater<>**, чтобы элементы извлекались по возрастанию).
- Время работы также измеряется в секундах.

```cpp
        performanceMetrics.emplace_back(size, make_pair(treeDuration, heapDuration));
        // Результаты для текущего размера массива добавляются в вектор performanceMetrics.
    }
```

- Результаты (размер массива, время работы турнирного дерева и мин-кучи) сохраняются для последующего вывода.

```cpp
    writeResultsToFile(performanceMetrics, "Second.txt");
    // Вызывает функцию, которая записывает результаты измерений в файл "Second.txt".
```

- Сохранение результатов бенчмаркинга в файл.

```cpp
    cout << "Benchmarking completed. Results saved in Second.txt\n";
    // Выводит сообщение об успешном завершении тестирования.
```

- Информирование пользователя о завершении теста.

```cpp
    return 0;
    // Завершает работу программы с кодом возврата 0, что означает успешное выполнение.
}
```

---

### Заключение

Программа сравнивает производительность двух способов удаления минимального элемента из набора чисел:
- **TournamentTree** – реализовано через турнирное дерево, где после каждого извлечения происходит обновление структуры.
- **MinHeap (priority_queue с компаратором greater<>)** – стандартная реализация мин-кучи в C++.

Для различных размеров массивов происходит измерение времени, и результаты записываются в файл "Second.txt" для последующего анализа.
